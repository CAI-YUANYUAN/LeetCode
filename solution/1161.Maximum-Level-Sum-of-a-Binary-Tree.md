# 1161. Maximum Level Sum of a Binary Tree[最大层内元素和]

## 信息卡片

* 时间：2020-02-17
* 题目链接：[English](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)/[中文](https://leetcode-cn.com/problems/maximum-level-sum-of-a-binary-tree/)
* Tag：`Tree` `BFS`
## 题目描述
Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.  
Return the smallest level X such that the sum of all the values of nodes at level X is maximal.   

### Example 1:  
![Image text](https://raw.githubusercontent.com/Ryuui-tkb/LeetCode/master/img/1161_ex1.png)  
Input: [1,7,0,7,-8,null,null]  
Output: 2  
Explanation:   
Level 1 sum = 1.  
Level 2 sum = 7 + 0 = 7.  
Level 3 sum = 7 + -8 = -1.  
So we return the level with the maximum sum which is level 2.  

### Note:
1. The number of nodes in the given tree is between 1 and 10^4.
2. -10^5 <= node.val <= 10^5

## 参考答案   


#### 分析

这题的关键在于将符合条件的结点从1更改为其他值（如1 -> 2），并统计其数量

#### 思路
这里提供两种解法。
* 方法1: 将邻接矩阵转化为邻接数组or邻接链表，根据每个邻接表的数量判断是否符合条件;
* 方法2: 直接横向遍历和纵向遍历矩阵，寻找符合条件的元素

#### 代码

##### JAVA

1.邻接数组/邻接链表法

* Runtime: 3 ms, faster than 79.81% of Java online submissions for Count Servers that Communicate.
* Memory Usage: 44.9 MB, less than 100.00% of Java online submissions for Count Servers that Communicate.

```Java
/**
 * @author RyuuI
 */
class Solution {
    public int countServers(int[][] grid) {
		int row_count = grid.length;
		int col_count = grid[0].length;
		int connected_count =0;
		
		//创建横向的邻接数组和纵向的邻接数组
		ArrayList<Integer> grid_rowlist[] = new ArrayList[row_count];
		ArrayList<Integer> grid_collist[] = new ArrayList[col_count];
		for(int i=0;i<row_count;i++){
			grid_rowlist[i] = new ArrayList<Integer>();
		}
		for(int i=0;i<col_count;i++){
			grid_collist[i] = new ArrayList<Integer>();
		}
		
		//将值等于1的元素加入邻接数组
		for(int i=0;i<row_count;i++){
			for(int j =0;j<col_count;j++){
				if(grid[i][j] ==1){
					grid_rowlist[i].add(j);
					grid_collist[j].add(i);					
				}
			}
		}
		
		//检查横向的邻接数组，将size>=2的临界数组计入connected_count，并修改元素值
		for(int i=0;i<row_count;i++){
			if(grid_rowlist[i].size()>1){
				connected_count += grid_rowlist[i].size();
				for(int j:grid_rowlist[i]){
					grid[i][j] = -1;
				}				
			}
		}
		
		//检查纵向的邻接数组，注意只有元素值未修改过的元素才能计入connected_count
		for(int i =0;i<col_count;i++){
			if(grid_collist[i].size()>1){
				for(int j:grid_collist[i]){
					if(grid[j][i] != -1)
						connected_count++;
				}
			}
		}
		return connected_count;
        
    }
}
```


2.横向遍历+纵向遍历法

* Runtime: 2 ms, faster than 99.04% of Java online submissions for Count Servers that Communicate.
* Memory Usage: 47 MB, less than 100.00% of Java online submissions for Count Servers that Communicate.

```Java
/**
 * @author RyuuI
 */
class Solution {
    public int countServers(int[][] grid) {
		int connected_count =0;
		
		//横向遍历，将符合条件的元素值修改
		for(int i=0;i<grid.length;i++){
			int k=-1;
			for(int j=0;j<grid[0].length;j++){
				if(grid[i][j] >=1){
					if(k == -1){
						k =j;
						continue;
					}
					grid[i][k] =2;
					grid[i][j] =2;
				}
			}
		}
		
		//纵向遍历，将符合条件的元素值修改
		for(int j=0;j<grid[0].length;j++){
			int k=-1;
			for(int i=0;i<grid.length;i++){
				if(grid[i][j] >=1 ){
					if(k == -1){
						k =i;
						continue;
					}
					grid[k][j] =2;
					grid[i][j] =2;
				}
			}
			
		}
		
		//统计修改后的元素数量
		for(int i=0;i<grid.length;i++){
			for(int j=0;j<grid[0].length;j++)
				if(grid[i][j] == 2)
					connected_count++;
					
		}
		return connected_count;  
    }
}
```

##### C++


##### Python


## 优秀解答

>暂缺







```
Runtime: 8 ms, faster than 75.79% of Java online submissions for Maximum Level Sum of a Binary Tree.
Memory Usage: 43.2 MB, less than 100.00% of Java online submissions for Maximum Level Sum of a Binary Tree.

//1.迭代
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxLevelSum(TreeNode root) {
		int maxSum = Integer.MIN_VALUE;
		int sum =0;
		int maxLevel = 0;
		int level =1;
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		queue.offer(root);
		queue.offer(null);
		
		while(queue.size()>1){
			TreeNode head = queue.poll();
			sum += head.val;
			
			if(head.left!= null)
				queue.offer(head.left);
			if(head.right != null)
				queue.offer(head.right);
			
			if(queue.peek() == null){
				queue.poll();
				queue.offer(null);
				if(maxSum<sum){
					maxSum = sum;
					maxLevel = level;
				}
                sum =0;
				level++;
			}
			
			
		}
		return maxLevel;
        
    }
}
```


```
Runtime: 4 ms, faster than 98.05% of Java online submissions for Maximum Level Sum of a Binary Tree.
Memory Usage: 42.7 MB, less than 100.00% of Java online submissions for Maximum Level Sum of a Binary Tree.

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
	ArrayList<Integer> max_sum = new ArrayList<Integer>();
	public int maxLevelSum(TreeNode root) {
		int max = Integer.MIN_VALUE;
		int index =0;
		max_sum.add(Integer.MIN_VALUE);
		helper(root,1);
		for(int i=1;i<max_sum.size();i++){
			if(max<max_sum.get(i)){
				max = max_sum.get(i);
				index = i;
			}

		}
		return index;
	}


	private void helper(TreeNode node, int level){
		if(level == max_sum.size())
			max_sum.add(node.val);
		else{
			max_sum.set(level,max_sum.get(level)+node.val);
		}
		if(node.left != null)
			helper(node.left,level+1);
		if(node.right != null)
			helper(node.right,level+1);
	}
}
```
