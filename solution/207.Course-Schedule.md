# 207.Course Schedule[课程表]

## 信息卡片

* 时间：2020-03-03
* 题目链接：[English](https://leetcode.com/problems/course-schedule/)/[中文](https://leetcode-cn.com/problems/course-schedule/)
* Tag：`Graph` `BFS` `DFS` `Topological Sort`
## 题目描述
There are a total of n courses you have to take, labeled from 0 to n-1.  
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]  
Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?  

### Example 1:  
Input: 2, [[1,0]]  
Output: true  
Explanation: There are a total of 2 courses to take.  
             To take course 1 you should have finished course 0. So it is possible.  

### Example 2:
Input: 2, [[1,0],[0,1]]  
Output: false   
Explanation: There are a total of 2 courses to take.  
             To take course 1 you should have finished course 0, and to take course 0 you should  
             also have finished course 1. So it is impossible.  

### Note:
1. The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
2. You may assume that there are no duplicate edges in the input prerequisites.



## 参考答案   


#### 分析

这道题是层次遍历的算法，只要遍历每一层，并且计算其平均值即可。值得注意的是，本题的存储要考虑到int型可能发生溢出，所以应该使用long型存储和的结果。  

#### 思路
略

#### 代码

##### JAVA

1.递归法

* Runtime: 2 ms, faster than 93.92% of Java online submissions for Average of Levels in Binary Tree.
* Memory Usage: 42.9 MB, less than 8.00% of Java online submissions for Average of Levels in Binary Tree.

```Java
/**
 * @author RyuuI
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
	List<Long> sum_list = new ArrayList<Long>();
	List<Integer> count_list = new ArrayList<Integer>();
	List<Double> result_list = new ArrayList<Double>();
    public List<Double> averageOfLevels(TreeNode root) {
		helper(root,0);
		
		for(int i=0;i<count_list.size();i++)
		{
			result_list.add(((double)(sum_list.get(i))/count_list.get(i)));
		}
		return result_list;
    }
	
	private void helper(TreeNode node,int level)
	{
		if(sum_list.size() == level)
		{
			sum_list.add((long)node.val);	
			count_list.add(1);
		}
		else
		{
			sum_list.set(level,sum_list.get(level)+node.val);
			count_list.set(level,count_list.get(level)+1);
		}
		if(node.left != null)
			helper(node.left,level+1);
		if(node.right != null)
			helper(node.right,level +1);
	}
}
```


2.迭代法  

* Runtime: 5 ms, faster than 11.58% of Java online submissions for Average of Levels in Binary Tree.
* Memory Usage: 44.7 MB, less than 8.00% of Java online submissions for Average of Levels in Binary Tree.

```Java
/**
 * @author RyuuI
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
		List<Double> list =  new ArrayList<Double>();
		if(root==null)
			return list;
		
		Queue<TreeNode> queue = new LinkedList<TreeNode>();
		queue.offer(root);
		queue.offer(null);
		long sum =0;
		int count =0;
		
		while(queue.size()>1)
		{
			TreeNode top = queue.remove();
			sum += top.val;
			count++;
			
			if(top.left != null)
				queue.offer(top.left);
			if(top.right != null)
				queue.offer(top.right);
			
			if(queue.peek() ==null)
			{
				list.add(((double)sum)/count);
				sum =0;
				count =0;
				queue.remove();
				queue.offer(null);
			}
		}
		return list;   
    }
}
```

##### C++


##### Python


## 优秀解答

>暂缺
