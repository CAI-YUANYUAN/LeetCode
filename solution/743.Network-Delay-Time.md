# 743. Network Delay Time[网络延迟时间]

## 信息卡片

* 时间：2020-02-18
* 题目链接：[English](https://leetcode.com/problems/network-delay-time/)/[中文](https://leetcode-cn.com/problems/network-delay-time/)
* Tag：`Graph`
## 题目描述
There are N network nodes, labelled 1 to N.  
Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.  
Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.  

### Example 1:  
![Image text](https://raw.githubusercontent.com/Ryuui-tkb/LeetCode/master/img/743_ex1.png)  
Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2  
Output: 2  

### Note:
1. N will be in the range [1, 100].
2. K will be in the range [1, N].
3. The length of times will be in the range [1, 6000].
4. All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 0 <= w <= 100.


## 参考答案   


#### 分析

这题的关键在于将符合条件的结点从1更改为其他值（如1 -> 2），并统计其数量

#### 思路
这里提供两种解法。
* 方法1: 将邻接矩阵转化为邻接数组or邻接链表，根据每个邻接表的数量判断是否符合条件;
* 方法2: 直接横向遍历和纵向遍历矩阵，寻找符合条件的元素

#### 代码

##### JAVA

1.邻接数组/邻接链表法

* Runtime: 3 ms, faster than 79.81% of Java online submissions for Count Servers that Communicate.
* Memory Usage: 44.9 MB, less than 100.00% of Java online submissions for Count Servers that Communicate.

```Java
/**
 * @author RyuuI
 */
class Solution {
    public int countServers(int[][] grid) {
		int row_count = grid.length;
		int col_count = grid[0].length;
		int connected_count =0;
		
		//创建横向的邻接数组和纵向的邻接数组
		ArrayList<Integer> grid_rowlist[] = new ArrayList[row_count];
		ArrayList<Integer> grid_collist[] = new ArrayList[col_count];
		for(int i=0;i<row_count;i++){
			grid_rowlist[i] = new ArrayList<Integer>();
		}
		for(int i=0;i<col_count;i++){
			grid_collist[i] = new ArrayList<Integer>();
		}
		
		//将值等于1的元素加入邻接数组
		for(int i=0;i<row_count;i++){
			for(int j =0;j<col_count;j++){
				if(grid[i][j] ==1){
					grid_rowlist[i].add(j);
					grid_collist[j].add(i);					
				}
			}
		}
		
		//检查横向的邻接数组，将size>=2的临界数组计入connected_count，并修改元素值
		for(int i=0;i<row_count;i++){
			if(grid_rowlist[i].size()>1){
				connected_count += grid_rowlist[i].size();
				for(int j:grid_rowlist[i]){
					grid[i][j] = -1;
				}				
			}
		}
		
		//检查纵向的邻接数组，注意只有元素值未修改过的元素才能计入connected_count
		for(int i =0;i<col_count;i++){
			if(grid_collist[i].size()>1){
				for(int j:grid_collist[i]){
					if(grid[j][i] != -1)
						connected_count++;
				}
			}
		}
		return connected_count;
        
    }
}
```


2.横向遍历+纵向遍历法

* Runtime: 2 ms, faster than 99.04% of Java online submissions for Count Servers that Communicate.
* Memory Usage: 47 MB, less than 100.00% of Java online submissions for Count Servers that Communicate.

```Java
/**
 * @author RyuuI
 */
class Solution {
    public int countServers(int[][] grid) {
		int connected_count =0;
		
		//横向遍历，将符合条件的元素值修改
		for(int i=0;i<grid.length;i++){
			int k=-1;
			for(int j=0;j<grid[0].length;j++){
				if(grid[i][j] >=1){
					if(k == -1){
						k =j;
						continue;
					}
					grid[i][k] =2;
					grid[i][j] =2;
				}
			}
		}
		
		//纵向遍历，将符合条件的元素值修改
		for(int j=0;j<grid[0].length;j++){
			int k=-1;
			for(int i=0;i<grid.length;i++){
				if(grid[i][j] >=1 ){
					if(k == -1){
						k =i;
						continue;
					}
					grid[k][j] =2;
					grid[i][j] =2;
				}
			}
			
		}
		
		//统计修改后的元素数量
		for(int i=0;i<grid.length;i++){
			for(int j=0;j<grid[0].length;j++)
				if(grid[i][j] == 2)
					connected_count++;
					
		}
		return connected_count;  
    }
}
```

##### C++


##### Python


## 优秀解答

>暂缺
