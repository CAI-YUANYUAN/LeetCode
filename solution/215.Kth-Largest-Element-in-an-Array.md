# 215. Kth Largest Element in an Array[数组中的第K个最大元素]

## 信息卡片

* 时间：2020-06-21
* 题目链接：[English](https://leetcode.com/problems/kth-largest-element-in-an-array/)/[中文](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
* Tag：`Heap` `Divide and Conquer`
## 题目描述
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

### Example 1:  
Input: [3,2,1,5,6,4] and k = 2  
Output: 5  

### Example 2:
Input: [3,2,3,1,2,4,5,5,6] and k = 4  
Output: 4  

### Note:
You may assume k is always valid, 1 ≤ k ≤ array's length.  



## 参考答案   


#### 分析
链接名称
这道题和[207. Course Schedule](https://github.com/Ryuui-tkb/LeetCode/blob/master/solution/207.Course-Schedule.md)的解法并没有太大的区别，只不过需要增加课程的路径数组。   
实质求的是AOV图中是否存在环。如果存在环，证明两门课程之间互为前置课程，因而形成矛盾。如果不存在环，则要输出该数组。

#### 思路
AOV图的求解，可以使用拓扑排序或者遍历算法判断是否存在环。  
* 拓扑排序：对于AOV图，寻找环是否存在的首选方法是拓扑排序。从一个入度为0的顶点开始，依次删除入度为0的顶点，并将该顶点指向的下一个顶点的入度减-1，判断是否最后所有的顶点都可以被删除。如果所有顶点都可以被删除，证明该AOV图可以遍历所有顶点。并且记录遍历过的顶点。
* 遍历算法：这里采用了DFS法。在遍历算法中，判断环是否存在的方式是已经访问过的顶点是否再次被访问。如果再次被访问，证明存在环。我们可以使用-1, 0, 1记录顶点的状态。如-1表示该顶点在该次循环中已经被访问过，0代表顶点未被访问过，1代表顶点已经遍历并且合法。另外，需要跟踪访问过的顶点。这里使用一个stack进行存储。我们可以知道，后继顶点一定是在栈底的，因为DFS中，会先存储最底层的顶点。

#### 代码

##### JAVA

1.拓扑排序

* Runtime: 4 ms, faster than 85.64% of Java online submissions for Course Schedule II.
* Memory Usage: 42.6 MB, less than 96.34% of Java online submissions for Course Schedule II.

```Java
/**
 * @author RyuuI
 */
class Solution {
	public int[] findOrder(int numCourses, int[][] prerequisites) {
		if(numCourses ==0)
			return (new int[0]);
		Stack<Integer> stack = new Stack<Integer>();
		LinkedList<Integer> adj[] = new LinkedList[numCourses];
		for(int i=0;i<adj.length;i++){
			adj[i] = new LinkedList<Integer>();
		}
		int[] count = new int[numCourses];
		int[] result = new int[numCourses];
		int index = 0;

		for(int[] prerequisite:prerequisites){
			count[prerequisite[0]] += 1;
			adj[prerequisite[1]].add(prerequisite[0]);
		}
		for(int i=0;i<count.length;i++){
			if(count[i] ==0)
				stack.push(i);
		}

		while(!stack.isEmpty()){
			int top = stack.pop();
			result[index] = top;
			index++;
			for(int num:adj[top]){
				count[num] -= 1;
				if(count[num] ==0)
					stack.push(num);
			}
		}
		if(index != numCourses)
			return (new int[0]);
		return result;
	}
}
```


2.DFS法  

* Runtime: 4 ms, faster than 85.64% of Java online submissions for Course Schedule II.
* Memory Usage: 42.7 MB, less than 96.34% of Java online submissions for Course Schedule II.

```Java
/**
 * @author RyuuI
 */
class Solution {
	LinkedList<Integer> adj[];
	int[] visited;
	Stack<Integer> stack;
	public int[] findOrder(int numCourses, int[][] prerequisites) {
		if(numCourses <= 0)
			return (new int[0]);
		stack = new Stack<Integer>();
		int[] result = new int[numCourses];

		adj = new LinkedList[numCourses];
		for(int i=0;i<numCourses;i++){
			adj[i] = new LinkedList<Integer>();
		}

		visited = new int[numCourses];

		for(int[] prerequisite:prerequisites){
			adj[prerequisite[1]].add(prerequisite[0]);
		}
		for(int i=0; i< numCourses;i++){
			if(!helper(adj,i,visited))
				return (new int[0]);
		}
		for(int i=0;i<numCourses;i++){
			result[i] = stack.pop();
		}


		return result;

	}

	private boolean helper(LinkedList<Integer> adj[], int start, int[] visited){
		if(visited[start] == 1)
			return true;
		if(visited[start] == -1)
			return false;
		visited[start] =-1;

		for(int num:adj[start]){
			if(!helper(adj, num, visited))
				return false;
		}
		visited[start] = 1;
		stack.push(start);
		return true;

	}
}
```

##### C++


##### Python


## 优秀解答

>暂缺
